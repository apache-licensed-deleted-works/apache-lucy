parcel Lucy;

/** Text field type.
 * 
 * Lucy::Plan::TextType is an implementation of
 * L<Lucy::Plan::FieldType> tuned for unicode string values.
 *
 * It is typical to use TextType fields with an
 * L<Analyzer|Lucy::Analysis::Analyzer> to tokenize and normalize the
 * text so that it may be searched for individual "words".  If no Analyzer is
 * supplied to TextType's constructor, the complete field value will be
 * treated as a single exact-match token.
 */
class Lucy::Plan::TextType extends Lucy::Plan::FieldType 
    : dumpable {

    bool_t      highlightable;
    Analyzer   *analyzer;

    /** 
     * @param analyzer An Analyzer, which will optionally be used to tokenize
     * and normalize field values.
     * @param similarity A Similarity.
     * @param boost floating point per-field boost.
     * @param indexed boolean indicating whether the field should be indexed.
     * @param stored boolean indicating whether the field should be stored.
     * @param sortable boolean indicating whether the field should be sortable.
     * @param highlightable boolean indicating whether the field should be
     * highlightable.
     */
    public inert TextType* 
    init(TextType *self, Analyzer *analyzer = NULL, 
         Similarity *similarity = NULL);

    inert TextType* 
    init2(TextType *self, Analyzer *analyzer = NULL, 
          Similarity *similarity = NULL, float boost = 1.0,
          bool_t indexed = true, bool_t stored = true, 
          bool_t sortable = false, bool_t highlightable = false);

    public inert incremented TextType* 
    new(Analyzer *analyzer, Similarity *similarity = NULL);

    public void
    Destroy(TextType *self);

    /** Indicate whether to store data required by
     * L<Lucy::Highlight::Highlighter> for excerpt selection and search
     * term highlighting. 
     */ 
    public void
    Set_Highlightable(TextType *self, bool_t highlightable);

    /** Accessor for "highlightable" property. 
     */
    public bool_t
    Highlightable(TextType *self);

    /** Accessor for "analyzer" member. 
     */
    public nullable Analyzer*
    Get_Analyzer(TextType *self);

    incremented CharBuf*
    Make_Blank(TextType *self);

    uint8_t
    Scalar_Type_ID(TextType *self);

    incremented Hash*
    Dump_For_Schema(TextType *self);

    public incremented Hash*
    Dump(TextType *self);

    public incremented TextType*
    Load(TextType *self, Obj *dump);

    public bool_t
    Equals(TextType *self, Obj *other);
} 

/* Copyright 2010 The Apache Software Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

